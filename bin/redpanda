#!/usr/bin/env perl6
use Module::Toolkit;
use Shell::Command;
use File::Temp;
use JSON::Fast;

my $mt = Module::Toolkit.new;

my $workdir = $*CWD.child('.redpanda-work');

#LEAVE rm_rf $workdir;

class X::Redpanda is Exception {
}

sub do-resolve(Distribution $dist,
               Bool() :$notests,
               Bool() :$force,
               Bool() :$update,
               Bool() :$verbose) {

    sub test($dir) {
        if $verbose {
            $mt.test($dir, output => $*OUT)
        } else {
            $mt.test($dir)
        }
    }

    my $tmpdir = tempdir(:tempdir($workdir), :!unlink);
    mkpath $tmpdir;
    say "Fetching {$dist.name}";
    $mt.fetch($dist, $tmpdir.IO);
    unless $notests {
        say "Testing {$dist.name}";
        unless test($tmpdir.IO) or $force {
            say "Tests failed for {$dist.name}";
            die X::Redpanda.new;
        }
    }
    say "Installing {$dist.name} ($tmpdir)";
    $mt.install($tmpdir.IO, :force($force or $update));
    say "Successfully installed {$dist.name}";
}

sub find-meta-file(IO::Path() $dir) {
    if $dir.child('META6.json').f {
        return $dir.child('META6.json')
    }
    if $dir.child('META.info').f {
        return $dir.child('META.info')
    }
}

sub dist-from-location(Str $location) {
    my $tmpdir = tempdir(:tempdir($workdir), :!unlink);
    mkpath $tmpdir;
    try {
        $mt.fetch($location, $tmpdir.IO);
        CATCH { default {
            return False;
        }}
    }

    my $meta = find-meta-file($tmpdir.IO);
    if $meta {
        my $dist = from-json slurp $meta;
        my @dep  = |($dist<depends>:delete);
        my @bdep = |($dist<build-depends>:delete);
        my @tdep = |($dist<test-depends>:delete);

        return Module::Toolkit::Distribution.new(
            |$dist,
            depends       => @dep,
            build-depends => @bdep,
            test-depends  => @tdep,
            source-url    => $tmpdir,
        );
    }
    return False;
}

sub MAIN(*@targets,
         Bool :$n = False, Bool :$notests = $n,
         Bool :$f = False, Bool :$force   = $f,
         Bool :$u = False, Bool :$update  = $u,
         Bool :$v = False, Bool :$verbose = $v) {

    sub resolve($target) {
        do-resolve($target, :$notests, :$force, :$verbose, :$update)
    };

    sub should-skip($target) {
        !$force and !$update and $mt.is-installed($target);
    }

    TARGETLOOP: for @targets -> $name {
        my $dist = $mt.get-project($name);
        unless $dist {
            $dist = dist-from-location($name);
            if $dist {
                say "Installing {$dist.name} "
                  ~ "from a custom location $name";
            } else {
                say "I don't know how to install $name :(";
                exit 1;
            }
        }
        if should-skip($dist) {
            say "{$dist.name} is already installed";
            next TARGETLOOP;
        }
        my @deps = $mt.get-dependencies($dist);
        say "{$dist.name} depends on {@depsÂ».name.join(", ")}" if +@deps;
        for @deps -> $dep {
            if should-skip($dep) {
                say "{$dep.name} is already installed";
                next;
            }
            &resolve($dep);
            CATCH { when X::Redpanda {
                say "Dependencies for {$dist.name} could not be installed";
                next TARGETLOOP;
            }}
        }
        &resolve($dist);
        CATCH { when X::Redpanda {
            say "Unable to install {$dist.name}";
        }}
    }
}
